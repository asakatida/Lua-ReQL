local json = require('json')

local errors = require('./errors')
local net = require('./net')
local proto_term_type = require('./proto').TermType

local is_instance = errors.is_instance
local is_array = errors.is_array

-- rethinkdb is both the main export object for the module
local rethinkdb = { }

local func_wrap, has_implicit, intsp, kved, intspallargs, should_wrap

local TermBase, RDBVal, DatumTerm, RDBOp, RDBOpWrap, MakeArray, MakeObject, Var
local JavaScript, Http, Json, Binary, Args, UserError, Random, ImplicitVar, Db
local Table, Get, GetAll, Eq, Ne, Lt, Le, Gt, Ge, Not, Add, Sub, Mul, Div, Mod
local Append, Prepend, Difference, SetInsert, SetUnion, SetIntersection
local SetDifference, Slice, Skip, Limit, GetField, Bracket, Contains, InsertAt
local SpliceAt, DeleteAt, ChangeAt, HasFields, WithFields, Keys, Changes
local Object, Pluck, IndexesOf, Without, Merge, Between, Reduce, Map, Filter
local ConcatMap, OrderBy, Distinct, Count, Union, Nth, Match, Split, Upcase
local Downcase, IsEmpty, Group, Sum, Avg, Min, Max, InnerJoin, OuterJoin
local EqJoin, Zip, CoerceTo, Ungroup, TypeOf, Info, Sample, Update, Delete
local Replace, Insert, DbCreate, DbDrop, DbList, TableCreate, TableDrop
local TableList, IndexCreate, IndexDrop, IndexRename, IndexList, IndexStatus
local IndexWait, Sync, FunCall, Default, Branch, Any, All, ForEach, Func, Asc
local Desc, Literal, ISO8601, ToISO8601, EpochTime, ToEpochTime, Now
local InTimezone, During, ReQLDate, TimeOfDay, Timezone, Year, Month, Day
local DayOfWeek, DayOfYear, Hours, Minutes, Seconds, Time, GeoJson, ToGeoJson
local Point, Line, Polygon, Distance, Intersects, Includes, Circle
local GetIntersecting, GetNearest, Fill, UUID, Monday, Tuesday, Wednesday
local Thursday, Friday, Saturday, Sunday, January, February, March, April, May
local June, July, August, September, October, November, December

-- Utilities

function func_wrap(val, optargs)
  if not val then
    -- Pass through the nil value so it's caught by
    -- the appropriate nil checker
    return val
  end
  val = rethinkdb.expr(val, nil, optargs)
  function ivar_scan(node)
    if not is_instance(TermBase, node) then
      return false
    end
    if is_instance(ImplicitVar, node) then
      return true
    end
    for _, v in ipairs(node.args) do
      if ivar_scan(v) then
        return true
      end
    end
    for _, v in pairs(node.optargs) do
      if ivar_scan(v) then
        return true
      end
    end
    return false
  end
  if ivar_scan(val) then
    return Func(optargs, function(x)
      return val
    end)
  end
  return val
end
function has_implicit(args)
  -- args is an array of (strings and arrays)
  -- We recurse to look for `r.row` which is an implicit var
  if type(args) == 'table' then
    for _, arg in ipairs(args) do
      if has_implicit(arg) == true then
        return true
      end
    end
  else
    if args == 'r.row' then
      return true
    end
  end
  return false
end

-- AST classes

do
  local _base_0 = {
    run = function(self, connection, options, callback)
      -- Valid syntaxes are
      -- connection, callback
      -- connection, options, callback
      -- connection, nil, callback

      -- Handle run(connection, callback)
      if type(options) == "function" then
        if not (callback) then
          callback = options
          options = { }
        else
          options(errors.ReQLDriverError("Second argument to `run` cannot be a function if a third argument is provided."))
          return
        end
      else
        -- else we suppose that we have run(connection[, options][, callback])
        if not (options) then
          options = { }
        end
      end

      if not net.is_connection(connection) then
        if callback then
          return callback(errors.ReQLDriverError("First argument to `run` must be an open connection."))
        end
        return
      end

      return connection:_start(self, callback, options)
    end,
  }
  _base_0.__index = _base_0
  local _class_0 = setmetatable({
    __init = function(self)
      self = function(self, field)
        return self.bracket(field)
      end
      return self
    end,
    __base = _base_0,
    __name = "TermBase"
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  TermBase = _class_0
end
do
  local _parent_0 = TermBase
  local _base_0 = {
    eq = function(...)
      return Eq({ }, ...)
    end,
    ne = function(...)
      return Ne({ }, ...)
    end,
    lt = function(...)
      return Lt({ }, ...)
    end,
    le = function(...)
      return Le({ }, ...)
    end,
    gt = function(...)
      return Gt({ }, ...)
    end,
    ge = function(...)
      return Ge({ }, ...)
    end,
    not_ = function(...)
      return Not({ }, ...)
    end,
    add = function(...)
      return Add({ }, ...)
    end,
    sub = function(...)
      return Sub({ }, ...)
    end,
    mul = function(...)
      return Mul({ }, ...)
    end,
    div = function(...)
      return Div({ }, ...)
    end,
    mod = function(...)
      return Mod({ }, ...)
    end,
    append = function(...)
      return Append({ }, ...)
    end,
    prepend = function(...)
      return Prepend({ }, ...)
    end,
    difference = function(...)
      return Difference({ }, ...)
    end,
    set_insert = function(...)
      return SetInsert({ }, ...)
    end,
    set_union = function(...)
      return SetUnion({ }, ...)
    end,
    set_intersection = function(...)
      return SetIntersection({ }, ...)
    end,
    set_difference = function(...)
      return SetDifference({ }, ...)
    end,
    slice = function(self, left, right_or_opts, opts)
      if opts then
        return Slice(opts, self, left, right_or_opts)
      else
        if right_or_opts then
          if (type(right_or_opts) == 'table') and (not is_instance(TermBase, right_or_opts)) then
            return Slice(right_or_opts, self, left)
          else
            return Slice({ }, self, left, right_or_opts)
          end
        else
          return Slice({ }, self, left)
        end
      end
    end,
    skip = function(...)
      return Skip({ }, ...)
    end,
    limit = function(...)
      return Limit({ }, ...)
    end,
    get_field = function(...)
      return GetField({ }, ...)
    end,
    contains = function(...)
      return Contains({ }, ...)
    end,
    insert_at = function(...)
      return InsertAt({ }, ...)
    end,
    splice_at = function(...)
      return SpliceAt({ }, ...)
    end,
    delete_at = function(...)
      return DeleteAt({ }, ...)
    end,
    change_at = function(...)
      return ChangeAt({ }, ...)
    end,
    indexes_of = function(...)
      return IndexesOf({ }, ...)
    end,
    has_fields = function(...)
      return HasFields({ }, ...)
    end,
    with_fields = function(...)
      return WithFields({ }, ...)
    end,
    keys = function(...)
      return Keys({ }, ...)
    end,
    changes = function(...)
      return Changes({ }, ...)
    end,

    -- pluck and without on zero fields are allowed
    pluck = function(...)
      return Pluck({ }, ...)
    end,
    without = function(...)
      return Without({ }, ...)
    end,
    merge = function(...)
      return Merge({ }, ...)
    end,
    between = function(self, left, right, opts)
      return Between(opts, self, left, right)
    end,
    reduce = function(...)
      return Reduce({arity = 2}, ...)
    end,
    map = function(...)
      return Map({ }, ...)
    end,
    filter = function(self, predicate, opts)
      return Filter(opts, self, func_wrap(predicate))
    end,
    concat_map = function(...)
      return ConcatMap({ }, ...)
    end,
    distinct = function(self, opts)
      return Distinct(opts, self)
    end,
    count = function(...)
      return Count({ }, ...)
    end,
    union = function(...)
      return Union({ }, ...)
    end,
    nth = function(...)
      return Nth({ }, ...)
    end,
    bracket = function(...)
      return Bracket({ }, ...)
    end,
    match = function(...)
      return Match({ }, ...)
    end,
    split = function(...)
      return Split({ }, ...)
    end,
    upcase = function(...)
      return Upcase({ }, ...)
    end,
    downcase = function(...)
      return Downcase({ }, ...)
    end,
    is_empty = function(...)
      return IsEmpty({ }, ...)
    end,
    inner_join = function(...)
      return InnerJoin({ }, ...)
    end,
    outer_join = function(...)
      return OuterJoin({ }, ...)
    end,
    eq_join = function(self, left_attr, right, opts)
      return EqJoin(opts, self, func_wrap(left_attr), right)
    end,
    zip = function(...)
      return Zip({ }, ...)
    end,
    coerce_to = function(...)
      return CoerceTo({ }, ...)
    end,
    ungroup = function(...)
      return Ungroup({ }, ...)
    end,
    type_of = function(...)
      return TypeOf({ }, ...)
    end,
    update = function(self, func, opts)
      return Update(opts, self, func_wrap(func))
    end,
    delete = function(self, opts)
      return Delete(opts, self)
    end,
    replace = function(self, func, opts)
      return Replace(opts, self, func_wrap(func))
    end,
    do_ = function(self, ...)
      local args = {...}
      local func = func_wrap(args[args.n])
      args[args.n] = nil
      return FunCall({ }, func, self, unpack(args))
    end,
    default = function(...)
      return Default({ }, ...)
    end,
    or_ = function(...)
      return Any({ }, ...)
    end,
    any = function(...)
      return Any({ }, ...)
    end,
    and_ = function(...)
      return All({ }, ...)
    end,
    all = function(...)
      return All({ }, ...)
    end,
    for_each = function(...)
      return ForEach({ }, ...)
    end,
    sum = function(...)
      return Sum({ }, ...)
    end,
    avg = function(...)
      return Avg({ }, ...)
    end,
    min = function(...)
      return Min({ }, ...)
    end,
    max = function(...)
      return Max({ }, ...)
    end,
    info = function(...)
      return Info({ }, ...)
    end,
    sample = function(...)
      return Sample({ }, ...)
    end,
    group = function(self, ...)
      -- Default if no opts dict provided
      local opts = { }
      local fields = {...}

      -- Look for opts dict
      if fields.n > 0 then
        local perhaps_opt_dict = fields[fields.n]
        if perhaps_opt_dict and (type(perhaps_opt_dict) == 'table') and not (is_instance(TermBase, perhaps_opt_dict)) then
          opts = perhaps_opt_dict
          fields[fields.n] = nil
          fields.n = fields.n - 1
        end
      end
      for i=1, fields.n do
        fields[i] = func_wrap(fields[i])
      end
      return Group(opts, self, unpack(fields))
    end,
    order_by = function(self, ...)
      -- Default if no opts dict provided
      local opts = { }
      local attrs = {...}

      -- Look for opts dict
      local perhaps_opt_dict = attrs[attrs.n]
      if perhaps_opt_dict and (type(perhaps_opt_dict) == 'table') and not is_instance(TermBase, perhaps_opt_dict) then
        opts = perhaps_opt_dict
        attrs[attrs.n] = nil
        attrs.n = attrs.n - 1
      end
      for i, attr in ipairs(attrs) do
        if not (is_instance(Asc, attr) or is_instance(Desc, attr)) then
          attrs[i] = func_wrap(attr)
        end
      end
      return OrderBy(opts, self, unpack(attrs))
    end,

    -- Geo operations
    to_geojson = function(...)
      return ToGeoJson({ }, ...)
    end,
    distance = function(self, g, opts)
      return Distance(opts, self, g)
    end,
    intersects = function(...)
      return Intersects({ }, ...)
    end,
    includes = function(...)
      return Includes({ }, ...)
    end,
    fill = function(...)
      return Fill({ }, ...)
    end,

    -- Database operations

    table_create = function(self, tbl_name, opts)
      return TableCreate(opts, self, tbl_name)
    end,
    table_drop = function(...)
      return TableDrop({ }, ...)
    end,
    table_list = function(...)
      return TableList({ }, ...)
    end,
    table = function(self, tbl_name, opts)
      return Table(opts, self, tbl_name)
    end,

    -- Table operations

    get = function(...)
      return Get({ }, ...)
    end,
    get_all = function(self, ...)
      -- Default if no opts dict provided
      local opts = { }
      local keys = {...}

      -- Look for opts dict
      if keys.n > 1 then
        local perhaps_opt_dict = keys[keys.n]
        if perhaps_opt_dict and ((type(perhaps_opt_dict) == 'table') and not (is_instance(TermBase, perhaps_opt_dict))) then
          opts = perhaps_opt_dict
          keys[keys.n] = nil
        end
      end
      return GetAll(opts, self, unpack(keys))
    end,
    insert = function(self, doc, opts)
      return Insert(opts, self, rethinkdb.expr(doc))
    end,
    index_create = function(self, name, defun_or_opts, opts)
      if opts then
        return IndexCreate(opts, self, name, func_wrap(defun_or_opts))
      else
        if defun_or_opts then
          -- FIXME?
          if (type(defun_or_opts) == 'table') and not is_instance(Function, defun_or_opts) and not is_instance(TermBase, defun_or_opts) then
            return IndexCreate(defun_or_opts, self, name)
          else
            return IndexCreate({ }, self, name, func_wrap(defun_or_opts))
          end
        else
          return IndexCreate({ }, self, name)
        end
      end
    end,
    index_drop = function(...)
      return IndexDrop({ }, ...)
    end,
    index_list = function(...)
      return IndexList({ }, ...)
    end,
    index_status = function(...)
      return IndexStatus({ }, ...)
    end,
    index_wait = function(...)
      return IndexWait({ }, ...)
    end,
    index_rename = function(self, old_name, new_name, opts)
      return IndexRename(opts, self, old_name, new_name)
    end,
    sync = function(...)
      return Sync({ }, ...)
    end,
    to_iso8601 = function(...)
      return ToISO8601({ }, ...)
    end,
    to_epoch_time = function(...)
      return ToEpochTime({ }, ...)
    end,
    in_timezone = function(...)
      return InTimezone({ }, ...)
    end,
    during = function(self, t2, t3, opts)
      return During(opts, self, t2, t3)
    end,
    date = function(...)
      return ReQLDate({ }, ...)
    end,
    time_of_day = function(...)
      return TimeOfDay({ }, ...)
    end,
    timezone = function(...)
      return Timezone({ }, ...)
    end,
    year = function(...)
      return Year({ }, ...)
    end,
    month = function(...)
      return Month({ }, ...)
    end,
    day = function(...)
      return Day({ }, ...)
    end,
    day_of_week = function(...)
      return DayOfWeek({ }, ...)
    end,
    day_of_year = function(...)
      return DayOfYear({ }, ...)
    end,
    hours = function(...)
      return Hours({ }, ...)
    end,
    minutes = function(...)
      return Minutes({ }, ...)
    end,
    seconds = function(...)
      return Seconds({ }, ...)
    end,
    uuid = function(...)
      return UUID({ }, ...)
    end,
    get_intersecting = function(self, g, opts)
      return GetIntersecting(opts, self, g)
    end,
    get_nearest = function(self, g, opts)
      return GetNearest(opts, self, g)
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "RDBVal",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  RDBVal = _class_0
end
do
  local _parent_0 = RDBVal
  local _base_0 = {
    args = { },
    optargs = { },
    compose = function(self)
      local _exp_0 = type(self.data)
      if 'string' == _exp_0 then
        return '"' .. self.data .. '"'
      else
        return '' .. self.data
      end
    end,
    build = function(self)
      if type(self.data) == 'number' then
        if math.abs(self.data) == 1/0 or self.data == ((1/0) * 0) then
          error(TypeError("Illegal non-finite number `" .. self.data:tostring() .. "`."))
        end
      end
      if self.data == nil then return json.null end
      return self.data
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __init = function(self, val)
      self.data = val
      return self
    end,
    __base = _base_0,
    __name = "DatumTerm",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  DatumTerm = _class_0
end
do
  local _parent_0 = RDBVal
  local _base_0 = {
    build = function(self)
      local args = {}
      for i, arg in ipairs(self.args) do
        args[i] = arg:build()
      end
      res = {self.tt, args}
      if #self.optargs > 0 then
        local opts = { }
        for key, val in pairs(self.optargs) do
          opts[key] = val:build()
        end
        table.insert(res, opts)
      end
      return res
    end,
    compose = function(self, args, optargs)
      if self.st then
        return {
          'r.',
          self.st,
          '(',
          intspallargs(args, optargs),
          ')'
        }
      else
        if self.args then
        if should_wrap(self.args[1]) then
          args[1] = {
            'r(',
            args[1],
            ')'
          }
        end
        end
        return {
          args[1],
          '.',
          self.mt,
          '(',
          intspallargs((function()
            local _accum_0 = { }
            for _index_0 = 2, #args do
              _accum_0[_index_0 - 1] = args[_index_0]
            end
            return _accum_0
          end)(), optargs),
          ')'
        }
      end
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __init = function(self, optargs, ...)
      self.args = {...}
      for i, a in ipairs(self.args) do
        self.args[i] = rethinkdb.expr(a)
      end
      if optargs == nil then optargs = {} end
      self.optargs = optargs
    end,
    __base = _base_0,
    __name = "RDBOp",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  RDBOp = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = { }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __init = function(self, optargs, ...)
      self = _parent_0.__init(self)
      self.args = {}
      for i, a in ipairs(arg) do
        self.args[i] = rethinkdb.expr(func_wrap(optargs, a))
      end
      if optargs == nil then optargs = {} end
      self.optargs = optargs
      return self
    end,
    __base = _base_0,
    __name = "RDBOpWrap",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  RDBOpWrap = _class_0
end
function intsp(seq)
  if seq[1] == nil then
    return { }
  end
  local res = {
    seq[1]
  }
  for _index_0 = 2, #seq do
    table.insert(res, ', ')
    table.insert(res, seq[_index_0])
  end
  return res
end
function kved(optargs)
  return {
    '{',
    intsp((function()
      local _accum_0 = { }
      local _len_0 = 1
      for k, v in pairs(optargs) do
        _accum_0[_len_0] = {
          k,
          ': ',
          v
        }
        _len_0 = _len_0 + 1
      end
      return _accum_0
    end)()),
    '}'
  }
end
function intspallargs(args, optargs)
  local argrepr = { }
  if #args > 0 then
    table.insert(argrepr, intsp(args))
  end
  if optargs and #optargs > 0 then
    if #argrepr > 0 then
      table.insert(argrepr, ', ')
    end
    table.insert(argrepr, kved(optargs))
  end
  return argrepr
end
function should_wrap(arg)
  return is_instance(DatumTerm, arg) or is_instance(MakeArray, arg) or is_instance(MakeObject, arg)
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MAKE_ARRAY,
    st = '[...]', -- This is only used by the `nil` argument checker
    compose = function(self, args)
      return {
        '[',
        intsp(args),
        ']'
      }
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "MakeArray",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  MakeArray = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MAKE_OBJECT,
    st = '{...}', -- This is only used by the `nil` argument checker
    compose = function(self, args, optargs)
      return kved(optargs)
    end,
    build = function(self)
      local res = { }
      for key, val in pairs(self.optargs) do
        res[key] = val:build()
      end
      return res
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __init = function(self, obj, nesting_depth)
      self.args = {}
      self.optargs = { }
      for key, val in pairs(obj) do
        self.optargs[key] = rethinkdb.expr(val, nesting_depth - 1)
      end
    end,
    __base = _base_0,
    __name = "MakeObject",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  MakeObject = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.VAR,
    compose = function(self, args)
      if not args then return {} end
      for i, v in ipairs(args) do
        args[i] = 'var_' .. v
      end
      return args
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Var",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Var = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.JAVASCRIPT,
    st = 'js'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "JavaScript",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  JavaScript = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.HTTP,
    st = 'http'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Http",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Http = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.JSON,
    st = 'json'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Json",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Json = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.BINARY,
    st = 'binary',
    compose = function(self)
      if #self.args == 0 then
        return 'r.binary(<data>)'
      else
        return _parent_0
      end
    end,
    build = function(self)
      if #self.args == 0 then
        local data = self.base64_data
        return {
          ['$reql_type$'] = 'BINARY',
          data = data
        }
      else
        return _parent_0
      end
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __init = function(self, data)
      if is_instance(TermBase, data) then
        local self = _parent_0.__init(self, { }, data)
      else
        if is_instance(Buffer, data) then
          local self = _parent_0.__init(self)
          self.base64_data = data.tostring("base64")
        else
          error(TypeError("Parameter to `r.binary` must be a Buffer object or ReQL query."))
        end
      end
      return self
    end,
    __base = _base_0,
    __name = "Binary",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Binary = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.ARGS,
    st = 'args'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Args",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Args = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.ERROR,
    st = 'error'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "UserError",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  UserError = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.RANDOM,
    st = 'random'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Random",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Random = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.IMPLICIT_VAR,
    compose = function(self)
      return {
        'r.row'
      }
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ImplicitVar",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ImplicitVar = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DB,
    st = 'db'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Db",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Db = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TABLE,
    st = 'table',
    compose = function(self, args, optargs)
      if is_instance(Db, self.args[0]) then
        return {
          args[0],
          '.table(',
          intspallargs((function()
            local _accum_0 = { }
            local _len_0 = 1
            for _index_0 = 2, #args do
              local a = args[_index_0]
              _accum_0[_len_0] = a
              _len_0 = _len_0 + 1
            end
            return _accum_0
          end)(), optargs),
          ')'
        }
      else
        return {
          'r.table(',
          intspallargs(args, optargs),
          ')'
        }
      end
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Table",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Table = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GET,
    mt = 'get'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Get",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Get = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GET_ALL,
    mt = 'get_all'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "GetAll",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  GetAll = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.EQ,
    mt = 'eq'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Eq",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Eq = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.NE,
    mt = 'ne'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Ne",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Ne = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.LT,
    mt = 'lt'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Lt",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Lt = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.LE,
    mt = 'le'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Le",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Le = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GT,
    mt = 'gt'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Gt",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Gt = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GE,
    mt = 'ge'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Ge",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Ge = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.NOT,
    mt = 'not_'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Not",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Not = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.ADD,
    mt = 'add'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Add",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Add = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SUB,
    mt = 'sub'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Sub",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Sub = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MUL,
    mt = 'mul'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Mul",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Mul = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DIV,
    mt = 'div'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Div",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Div = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MOD,
    mt = 'mod'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Mod",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Mod = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.APPEND,
    mt = 'append'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Append",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Append = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.PREPEND,
    mt = 'prepend'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Prepend",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Prepend = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DIFFERENCE,
    mt = 'difference'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Difference",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Difference = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SET_INSERT,
    mt = 'set_insert'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "SetInsert",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  SetInsert = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SET_UNION,
    mt = 'set_union'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "SetUnion",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  SetUnion = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SET_INTERSECTION,
    mt = 'set_intersection'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "SetIntersection",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  SetIntersection = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SET_DIFFERENCE,
    mt = 'set_difference'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "SetDifference",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  SetDifference = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SLICE,
    mt = 'slice'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Slice",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Slice = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SKIP,
    mt = 'skip'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Skip",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Skip = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.LIMIT,
    mt = 'limit'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Limit",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Limit = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GET_FIELD,
    mt = 'get_field'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "GetField",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  GetField = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.BRACKET,
    st = '(...)', -- This is only used by the `nil` argument checker
    compose = function(self, args)
      return {
        args[0],
        '(',
        args[1],
        ')'
      }
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Bracket",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Bracket = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.CONTAINS,
    mt = 'contains'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Contains",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Contains = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INSERT_AT,
    mt = 'insert_at'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "InsertAt",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  InsertAt = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SPLICE_AT,
    mt = 'splice_at'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "SpliceAt",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  SpliceAt = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DELETE_AT,
    mt = 'delete_at'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "DeleteAt",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  DeleteAt = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.CHANGE_AT,
    mt = 'change_at'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ChangeAt",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ChangeAt = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.CONTAINS,
    mt = 'contains'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Contains",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Contains = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.HAS_FIELDS,
    mt = 'has_fields'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "HasFields",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  HasFields = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.WITH_FIELDS,
    mt = 'with_fields'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "WithFields",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  WithFields = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.KEYS,
    mt = 'keys'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Keys",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Keys = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.CHANGES,
    mt = 'changes'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Changes",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Changes = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.OBJECT,
    mt = 'object'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Object",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Object = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.PLUCK,
    mt = 'pluck'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Pluck",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Pluck = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.INDEXES_OF,
    mt = 'indexes_of'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "IndexesOf",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  IndexesOf = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.WITHOUT,
    mt = 'without'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Without",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Without = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.MERGE,
    mt = 'merge'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Merge",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Merge = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.BETWEEN,
    mt = 'between'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Between",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Between = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.REDUCE,
    mt = 'reduce'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Reduce",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Reduce = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.MAP,
    mt = 'map'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Map",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Map = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.FILTER,
    mt = 'filter'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Filter",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Filter = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.CONCATMAP,
    mt = 'concat_map'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ConcatMap",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ConcatMap = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.ORDERBY,
    mt = 'order_by'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "OrderBy",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  OrderBy = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DISTINCT,
    mt = 'distinct'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Distinct",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Distinct = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.COUNT,
    mt = 'count'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Count",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Count = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.UNION,
    mt = 'union'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Union",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Union = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.NTH,
    mt = 'nth'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Nth",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Nth = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MATCH,
    mt = 'match'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Match",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Match = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.SPLIT,
    mt = 'split'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Split",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Split = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.UPCASE,
    mt = 'upcase'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Upcase",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Upcase = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DOWNCASE,
    mt = 'downcase'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Downcase",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Downcase = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.IS_EMPTY,
    mt = 'is_empty'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "IsEmpty",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  IsEmpty = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GROUP,
    mt = 'group'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Group",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Group = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.SUM,
    mt = 'sum'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Sum",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Sum = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.AVG,
    mt = 'avg'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Avg",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Avg = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.MIN,
    mt = 'min'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Min",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Min = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.MAX,
    mt = 'max'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Max",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Max = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INNER_JOIN,
    mt = 'inner_join'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "InnerJoin",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  InnerJoin = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.OUTER_JOIN,
    mt = 'outer_join'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "OuterJoin",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  OuterJoin = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.EQ_JOIN,
    mt = 'eq_join'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "EqJoin",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  EqJoin = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.ZIP,
    mt = 'zip'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Zip",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Zip = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.COERCE_TO,
    mt = 'coerce_to'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "CoerceTo",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  CoerceTo = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.UNGROUP,
    mt = 'ungroup'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Ungroup",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Ungroup = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TYPEOF,
    mt = 'type_of'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "TypeOf",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  TypeOf = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INFO,
    mt = 'info'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Info",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Info = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SAMPLE,
    mt = 'sample'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Sample",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Sample = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.UPDATE,
    mt = 'update'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Update",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Update = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DELETE,
    mt = 'delete'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Delete",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Delete = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.REPLACE,
    mt = 'replace'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Replace",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Replace = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INSERT,
    mt = 'insert'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Insert",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Insert = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DB_CREATE,
    st = 'db_create'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "DbCreate",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  DbCreate = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DB_DROP,
    st = 'db_drop'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "DbDrop",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  DbDrop = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DB_LIST,
    st = 'db_list'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "DbList",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  DbList = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TABLE_CREATE,
    mt = 'table_create'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "TableCreate",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  TableCreate = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TABLE_DROP,
    mt = 'table_drop'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "TableDrop",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  TableDrop = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TABLE_LIST,
    mt = 'table_list'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "TableList",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  TableList = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INDEX_CREATE,
    mt = 'index_create'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "IndexCreate",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  IndexCreate = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INDEX_DROP,
    mt = 'index_drop'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "IndexDrop",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  IndexDrop = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INDEX_RENAME,
    mt = 'index_rename'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "IndexRename",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  IndexRename = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INDEX_LIST,
    mt = 'index_list'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "IndexList",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  IndexList = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INDEX_STATUS,
    mt = 'index_status'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "IndexStatus",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  IndexStatus = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INDEX_WAIT,
    mt = 'index_wait'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "IndexWait",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  IndexWait = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SYNC,
    mt = 'sync'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Sync",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Sync = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.FUNCALL,
    st = 'do_', -- This is only used by the `nil` argument checker
    compose = function(self, args)
      if #args > 2 then
        return {
          'r.do_(',
          intsp((function()
            local _accum_0 = { }
            local _len_0 = 1
            for _index_0 = 2, #args do
              local a = args[_index_0]
              _accum_0[_len_0] = a
              _len_0 = _len_0 + 1
            end
            return _accum_0
          end)()),
          ', ',
          args[0],
          ')'
        }
      else
        if should_wrap(self.args[1]) then
          args[1] = {
            'r(',
            args[1],
            ')'
          }
        end
        return {
          args[1],
          '.do_(',
          args[0],
          ')'
        }
      end
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "FunCall",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  FunCall = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DEFAULT,
    mt = 'default'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Default",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Default = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.BRANCH,
    st = 'branch'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Branch",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Branch = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.ANY,
    mt = 'or_'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Any",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Any = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.ALL,
    mt = 'and_'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "All",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  All = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.FOREACH,
    mt = 'for_each'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ForEach",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ForEach = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.FUNC,
    compose = function(self, args)
      if has_implicit(args[1]) then
        return {
          args[1]
        }
      else
        local var_str = ""
        for i, arg in ipairs(args[1][2]) do -- ['0', ', ', '1']
          if i % 2 == 0 then
            var_str = var_str .. Var.compose(arg)
          else
            var_str = var_str .. arg
          end
        end
        return {
          'function(',
          var_str,
          ') { return ',
          args[1],
          '; }'
        }
      end
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __init = function(self, optargs, func)
      local args = { }
      local arg_nums = { }
      if not optargs then optargs = {} end
      for i=1, optargs.arity or 1 do
        table.insert(arg_nums, Func.next_var_id)
        table.insert(args, Var({ }, Func.next_var_id))
        Func.next_var_id = Func.next_var_id + 1
      end
      local body = func(unpack(args))
      if not body then
        error(errors.ReQLDriverError("Anonymous function returned `nil`. Did you forget a `return`?"))
      end
      optargs.arity = nil
      local args_arr = MakeArray({ }, unpack(arg_nums))
      _parent_0.__init(self, optargs, args_arr, body)
    end,
    __base = _base_0,
    __name = "Func",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  local self = _class_0
  self.next_var_id = 0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Func = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.ASC,
    st = 'asc'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Asc",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Asc = _class_0
end
do
  local _parent_0 = RDBOpWrap
  local _base_0 = {
    tt = proto_term_type.DESC,
    st = 'desc'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Desc",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Desc = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.LITERAL,
    st = 'literal'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Literal",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Literal = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.ISO8601,
    st = 'iso8601'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ISO8601",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ISO8601 = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TO_ISO8601,
    mt = 'to_iso8601'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ToISO8601",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ToISO8601 = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.EPOCH_TIME,
    st = 'epoch_time'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "EpochTime",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  EpochTime = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TO_EPOCH_TIME,
    mt = 'to_epoch_time'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ToEpochTime",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ToEpochTime = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.NOW,
    st = 'now'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Now",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Now = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.IN_TIMEZONE,
    mt = 'in_timezone'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "InTimezone",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  InTimezone = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DURING,
    mt = 'during'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "During",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  During = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DATE,
    mt = 'date'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ReQLDate",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ReQLDate = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TIME_OF_DAY,
    mt = 'time_of_day'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "TimeOfDay",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  TimeOfDay = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TIMEZONE,
    mt = 'timezone'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Timezone",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Timezone = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.YEAR,
    mt = 'year'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Year",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Year = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MONTH,
    mt = 'month'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Month",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Month = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DAY,
    mt = 'day'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Day",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Day = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DAY_OF_WEEK,
    mt = 'day_of_week'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "DayOfWeek",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  DayOfWeek = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DAY_OF_YEAR,
    mt = 'day_of_year'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "DayOfYear",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  DayOfYear = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.HOURS,
    mt = 'hours'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Hours",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Hours = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MINUTES,
    mt = 'minutes'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Minutes",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Minutes = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SECONDS,
    mt = 'seconds'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Seconds",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Seconds = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TIME,
    st = 'time'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Time",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Time = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GEOJSON,
    mt = 'geojson'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "GeoJson",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  GeoJson = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TO_GEOJSON,
    mt = 'to_geojson'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "ToGeoJson",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  ToGeoJson = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.POINT,
    mt = 'point'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Point",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Point = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.LINE,
    mt = 'line'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Line",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Line = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.POLYGON,
    mt = 'polygon'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Polygon",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Polygon = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DISTANCE,
    mt = 'distance'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Distance",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Distance = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INTERSECTS,
    mt = 'intersects'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Intersects",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Intersects = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.INCLUDES,
    mt = 'includes'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Includes",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Includes = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.CIRCLE,
    mt = 'circle'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Circle",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Circle = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GET_INTERSECTING,
    mt = 'get_intersecting'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "GetIntersecting",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  GetIntersecting = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.GET_NEAREST,
    mt = 'get_nearest'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "GetNearest",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  GetNearest = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.FILL,
    mt = 'fill'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Fill",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Fill = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.UUID,
    st = 'uuid'
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "UUID",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  UUID = _class_0
end


-- All top level exported functions

-- Wrap a native Lua value in an ReQL datum
function rethinkdb.expr(val, nesting_depth, optargs)
  if nesting_depth == nil then
    nesting_depth = 20
  end
  if nesting_depth <= 0 then
    error(errors.ReQLDriverError("Nesting depth limit exceeded"))
  end
  if type(nesting_depth) ~= "number" then
    error(errors.ReQLDriverError("Second argument to `r.expr` must be a number or nil."))
  end
  if type(val) == "function" then
    return Func(optargs, val)
  end
  if is_instance(TermBase, val) then
    return val
  end
  if type(val) == 'table' then
    if type(val.build) == 'function' then
      return val
    end
    if is_array(val) then
      for i, v in ipairs(val) do
        val[i] = rethinkdb.expr(v, nesting_depth - 1)
      end
      return MakeArray(optargs, unpack(val))
    end
    return MakeObject(val, nesting_depth)
  end
  return DatumTerm(val)
end
function rethinkdb.js(jssrc, opts)
  return JavaScript(opts, jssrc)
end
function rethinkdb.http(url, opts)
  return Http(opts, url)
end
function rethinkdb.json(...)
  return Json({ }, ...)
end
function rethinkdb.error(...)
  return UserError({ }, ...)
end
function rethinkdb.random(...)
  -- Default if no opts dict provided
  local opts = { }
  local limits = {...}

  -- Look for opts dict
  local perhaps_opt_dict = limits[limits.n]
  if perhaps_opt_dict and ((type(perhaps_opt_dict) == 'table') and not (is_instance(TermBase, perhaps_opt_dict))) then
    opts = perhaps_opt_dict
    limits[limits.n] = nil
  end
  return Random(opts, unpack(limits))
end
function rethinkdb.binary(data)
  return Binary(data)
end
rethinkdb.row = ImplicitVar({ })
function rethinkdb.table(tbl_name, opts)
  return Table(opts, tbl_name)
end
function rethinkdb.db(...)
  return Db({ }, ...)
end
function rethinkdb.db_create(...)
  return DbCreate({ }, ...)
end
function rethinkdb.db_drop(...)
  return DbDrop({ }, ...)
end
function rethinkdb.db_list(...)
  return DbList({ }, ...)
end
function rethinkdb.table_create(tbl_name, opts)
  return TableCreate(opts, tbl_name)
end
function rethinkdb.table_drop(...)
  return TableDrop({ }, ...)
end
function rethinkdb.table_list(...)
  return TableList({ }, ...)
end
function rethinkdb.do_(...)
  args = {...}
  func = func_wrap(args[args.n])
  args[args.n] = nil
  return FunCall({ }, func, unpack(args))
end
function rethinkdb.branch(...)
  return Branch({ }, ...)
end
function rethinkdb.asc(...)
  return Asc({ }, ...)
end
function rethinkdb.desc(...)
  return Desc({ }, ...)
end
function rethinkdb.eq(...)
  return Eq({ }, ...)
end
function rethinkdb.ne(...)
  return Ne({ }, ...)
end
function rethinkdb.lt(...)
  return Lt({ }, ...)
end
function rethinkdb.le(...)
  return Le({ }, ...)
end
function rethinkdb.gt(...)
  return Gt({ }, ...)
end
function rethinkdb.ge(...)
  return Ge({ }, ...)
end
function rethinkdb.or_(...)
  return Any({ }, ...)
end
function rethinkdb.any(...)
  return Any({ }, ...)
end
function rethinkdb.and_(...)
  return All({ }, ...)
end
function rethinkdb.all(...)
  return All({ }, ...)
end
function rethinkdb.not_(...)
  return Not({ }, ...)
end
function rethinkdb.add(...)
  return Add({ }, ...)
end
function rethinkdb.sub(...)
  return Sub({ }, ...)
end
function rethinkdb.div(...)
  return Div({ }, ...)
end
function rethinkdb.mul(...)
  return Mul({ }, ...)
end
function rethinkdb.mod(...)
  return Mod({ }, ...)
end
function rethinkdb.type_of(...)
  return TypeOf({ }, ...)
end
function rethinkdb.info(...)
  return Info({ }, ...)
end
function rethinkdb.literal(...)
  return Literal({ }, ...)
end
function rethinkdb.iso8601(str, opts)
  return ISO8601(opts, str)
end
function rethinkdb.epoch_time(...)
  return EpochTime({ }, ...)
end
function rethinkdb.now(...)
  return Now({ }, ...)
end
function rethinkdb.time(...)
  return Time({ }, ...)
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MONDAY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Monday",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Monday = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.TUESDAY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Tuesday",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Tuesday = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.WEDNESDAY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Wednesday",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Wednesday = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.THURSDAY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Thursday",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Thursday = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.FRIDAY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Friday",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Friday = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SATURDAY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Saturday",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Saturday = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SUNDAY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "Sunday",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Sunday = _class_0
end
rethinkdb.monday = Monday()
rethinkdb.tuesday = Tuesday()
rethinkdb.wednesday = Wednesday()
rethinkdb.thursday = Thursday()
rethinkdb.friday = Friday()
rethinkdb.saturday = Saturday()
rethinkdb.sunday = Sunday()
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.JANUARY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "January",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  January = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.FEBRUARY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "February",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  February = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MARCH
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "March",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  March = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.APRIL
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "April",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  April = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.MAY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "May",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  May = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.JUNE
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "June",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  June = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.JULY
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "July",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  July = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.AUGUST
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "August",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  August = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.SEPTEMBER
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "September",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  September = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.OCTOBER
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "October",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  October = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.NOVEMBER
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "November",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  November = _class_0
end
do
  local _parent_0 = RDBOp
  local _base_0 = {
    tt = proto_term_type.DECEMBER
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  local _class_0 = setmetatable({
    __base = _base_0,
    __name = "December",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        return _parent_0[name]
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  December = _class_0
end
rethinkdb.january = January()
rethinkdb.february = February()
rethinkdb.march = March()
rethinkdb.april = April()
rethinkdb.may = May()
rethinkdb.june = June()
rethinkdb.july = July()
rethinkdb.august = August()
rethinkdb.september = September()
rethinkdb.october = October()
rethinkdb.november = November()
rethinkdb.december = December()
function rethinkdb.object(...)
  return Object({ }, ...)
end
function rethinkdb.args(...)
  return Args({ }, ...)
end
function rethinkdb.geojson(...)
  return GeoJson({ }, ...)
end
function rethinkdb.point(...)
  return Point({ }, ...)
end
function rethinkdb.line(...)
  return Line({ }, ...)
end
function rethinkdb.polygon(...)
  return Polygon({ }, ...)
end
function rethinkdb.intersects(...)
  return Intersects({ }, ...)
end
function rethinkdb.distance(g1, g2, opts)
  return Distance(opts, g1, g2)
end
function rethinkdb.circle(cen, rad, opts)
  return Circle(opts, cen, rad)
end
function rethinkdb.uuid(...)
  return UUID({ }, ...)
end

-- Export all names defined on rethinkdb
return rethinkdb
